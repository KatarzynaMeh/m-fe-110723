# README

## Теоретическое занятие №9

Репозитарий содержит материалы по проектному занятию №9, посвященному работе с объектами в TypeScript.

**Объекты**
Пришла пора поговорить о создании объектов в TypeScript. В отличии от JavaScript, где мы могли делать с объектами все, что угодно - здесь придется себя ограничить. Этим ограничением является определение "шаблона" объекта. То есть, мы определяем, какие свойства есть у объекта, и какого они типа.
```
const simpleObj: { name: string, id: number };
simpleObj.name = 'Timon'; // Ok
simpleObj.id = 1; // Ok
simpleObj.age = 15; // Error - simpleObj does not know anything about the "age" property
```

Попробуем на практике.
1. Определяем двумерную точку. Нам нужно создать переменную `point`, которая будет хранить данные о коордиинатах точки в пространстве. Это будет объект со свойствами `x`, `y`. Оба свойства - числа.
2. Определим свой тип `CPoint`, который будет определять тип объекта, у которого есть свойства `x`, `y` (числа).
3. Пишем функцию `getMiddlePoint`. Она принимает 2 аргумента, которые содержат данные о двух точках в пространстве. Задача - найти точку между ними, которая делит соединяющий их отрезок пополам. Функция должна вернуть эту точку.
4. Пишем функцию `getDistance`, которая принимает 2 аргумента (данные о точках), и должна вернуть расстояние между этими точками (число). Расстояние считаем по формуле `sqrt( (x2-x1)^2 + (y2-y1)^2 )`.
5. Определить тип `Triangle`. Он должен хранить данные о треугольнике в 2-мерном пространстве, а именно - координаты трех его вершин, и цвет заливки (строка).
6. Пишем функцию `getPerimeter`. Она принимает аргумент с данными нашего треугольника, и должна вернуть его периметр (то есть суммарную длину сторон). Лучше будет воспользоваться функцией `getDistance` из задачи 4 для определения длин сторон.

**Интерфейсы**
Наверное, самый интересный момент в TypeScript это интерфейсы. Если вкратце - интерфейс это тоже способ указания "шаблона" объекта, то есть типов его свойств.

У тех, кто пришел в TypeScript из Java, может быть когнитивный диссонанс, но в TypeScript интерфейсы используются не для классов, а для объектов.
```
interface Point {
  x: number;
  y: number;
}

function printCoord(pt: Point) {
  console.log("The coordinate's x value is " + pt.x);
  console.log("The coordinate's y value is " + pt.y);
}

let point: Point = { x: 100, y: 100 };
printCoord(point);
```

То есть, мы определяем структуру объекта. Мы как бы говорим "аргумент pt функции printCoord - это должно быть нечто, что удовлетворяет шаблону Point, а именно - имеет свойства x, y числового типа".

Еще одна отсылка к Java. В TypeScript, значение имеет не иерархия наследования или принадлежность к типу, а "соответствие" шаблону. То есть, следующий код будет работать, несмотря на то, что аргумент printCoord не относитс к типу Point.
```
interface Point {
  x: number;
  y: number;
}

function printCoord(pt: Point) {
  console.log("The coordinate's x value is " + pt.x);
  console.log("The coordinate's y value is " + pt.y);
}

printCoord({ x: 100, y: 100 });
```

Возникает вопрос: а в чем отличие типов и интерфейсов? Зачем нужны интерфейсы, если есть типы?

Предназначение у обоих довольно сходное: определять структуру. Есть некоторые различия относительно расширяемости (добавление новых свойств в типы/интерфейсы), и в наследовании. Обычно для комбинаций типов, доменов значений, и работы с примитивами рекомендуют использовать типы. А для определения структуры объектов - интерфейсы. В документации сказано, что это отдается на решение разработчику.

Закрепим практикой.
1. Перепишем тип Triangle из предыдущего блока с использованием интерфейсов.
2. Реализуем интерфейс, который будет хранить данные о пользователе. У него будут имя (строка), фамилия (строка), год рождения (число), и адрес. Адрес должен быть объектом, который хранит улицу (строка), номер дома (число), и страну (строка).
3. Напишем функцию `cloneUser`. Она должна принимать объект пользователя, и возвращать его глубокую копию.

**Приведение типов**
Иногда возникает ситуация, когда нам нужно "рассмотреть" один тип, как другой. Или сказать TypeScript-у, что конкретную переменную нужно рассматривать как переменную иного типа, отличного от того, который задан при объявлении переменной. Такое будет полезно при разборе ответов от сервера, работе с DOM, и других местах где тип неизвестен.
```
interface IPoint {
  x: number,
  y: number
};

interface IVector {
  x: number,
  y: number,
  x1: number,
  y1: number
}

const point: IPoint = {
  x: 5, y: 5
}

const vector: IVector = {
  x: 0, y: 0, x1: 1, y1: 1
}

function getVectorLength(vector: IVector): number {
  return Math.sqrt( Math.pow(vector.x1 - vector.x, 2) + Math.pow(vector.y1 - vector.y, 2));
}

console.log(getVectorLength(vector));
//console.log(getVectorLength(point));
let almostVector = point as IVector;
almostVector.x1 = 10;
almostVector.y1 = 10;
console.log(getVectorLength(almostVector));
```

В приведенном выше примере, мы видим, что у нас есть переменная, объявленная как IPoint. Мы работаем с ней, как с точкой. А потом, в какой-то момент времени, мы можем сказать TypeScript-у, чтобы он рассматривал ее как вектор (IVector), и можем добавить ей дополнительные свойства. И дальше, мы можем работать с этой переменной как с вектором.

**Generics (обобщения)**
TypeScript, по аналогии с ОО-языками типа Java, C#, содержит также такую возможность как обобщения типов. Это возможность некоего "резервирования" типа в рамках функции/класса/интерфейса. Другими словами, при вызове функции/создании объекта по шаблону интерфейса, мы явно укажем этот тип (или эти типы), и код будет ориентироваться на этот тип.

Пока ничего не понятно. Давайте на примере. Рассмотрим пример из оригинальной документации. Нам нужно написать функцию, которая принимает аругмент ЛЮБОГО типа, и возвращает его же.
```
function returnArg(arg: any) : any {
  return arg;
}
```
Казалось бы, задача решена. Но не совсем. Во-первых, плохой вариант использовать тип any. Во-вторых, функция не имеет явно заданного типа возвращаемого значения. То есть, вызывающий код не сможет воспользоваться преимуществами TypeScript.

Было бы здорово, если бы мы могли сказать "эй, функция, ты получишь аргумент какого-то определенного типа. И именно этот тип будет типом возвращаемого тобой значения". Вот тут приходят на помощь дженерики.
```
function returnArg<T>(arg: T): T {
  return arg;
}
```
И в этом случае, мы сможем при вызове функции ЯВНО указать тип. То есть сказать "функция, в этом вызове ты получаешь тип number, а в этом - string".
```
returnArg<number>(5); // 5
returnArg<string>("timon"); // timon
```
Дженерики также могут быть очень полезны для интерфейсов и классов. Например, у нас был определен интерфейс для данных пользователя.
```
interface IUser {
  id: number,
  name: string
}
```
Затем, в бэке что-то поменялось, и в качестве ID мы будем использовать строку. Как обеспечить совместимость? Опять на помощь приходят дженерики.
```
interface IUser<T> {
  id: T,
  name: string
}
```

Давайте попробуем на более "приземленном" примере. Рассмотрим реализацию метода `map` на JavaScript.
```
function customMap(array, callback) {
  let result = [];
  for (let i = 0; i < array.length; i++) {
    result.push( callbackl(array[i], i, array) );
  }
  return result;
}
```
И теперь попробуем ее переписать на TypeScript. У нас на "вход" заходит массив элементов какого-то типа. Колбэк-функция должна принимать элемент этого массива (то есть аргумент этого типа), индекс элемента (число), и сам массив, и возвращать элемент результирующего массива уже нового типа. То есть, мы видим, что у нас есть как минимум 2 обобщения типов. Попробуем записать это в TypeScript.
```
function customMap<T,R>( array: T[], callback: (elem: T, index: number, thisArg: T[]) => R ): R[] {
  let result: R[] = [];
  for (let i = 0; i < array.length; i++) {
    result.push( callback(array[i], i, array) );
  }
  return result;
}
```

## Полезные ссылки по занятию:
 - [Курс по TypeScript](https://www.youtube.com/watch?v=5IHc2qufxxM&list=PLM7wFzahDYnF9OoHLukLGX2XVJYLqLg4B ) - очень подробный и доходчивый вводный курс по TypeScript.
 - [Документация](https://www.typescriptlang.org/docs/) - англоязычная документация. На удивление, у них весьма толковый handbook - рекомендуется к ознакомлению (лучше параллельно с видеокурсом из п.1).