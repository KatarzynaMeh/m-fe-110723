# README

## Теоретическое занятие №7

Репозитарий содержит материалы по проектному занятию №7, посвященному знакомству с TypeScript.

**Что такое TypeScript**
По большому счету, TypeScript - это надстройка над уже известным нам JavaScript, которая добавляет сильную типизацию. То есть любой JS-окд является кодом TypeScript. Но не наоборот!

TypeScript, в отличие от JS, непонятен браузеру. Аннотации типов, некоторые ключевые слова, и еще ряд отличий от привычного JS делают код TypeScript невозможным для прямого запуска в браузере. Поэтому, нам нужно предварительно скомпилировать этот код, и получить "на выходе" обычный JavaScript, который может быть обработан браузером. И для этого нам понадобится компилятор, а также установка и настройка некоторых моментов.

**Почему TypeScript**
Логичный вопрос - а зачем TypeScript, когда есть JavaScript. Причин тому несколько:
 - сильная типизация СУЩЕСТВЕННО уменьшает вероятность появления ошибок при разработке и сокращает количество потенциальных багов. Это основной плюс.
 - аннотации типов делают код понятнее (субъективно, но тем не менее).
 - большинство вакансий содержат это требование (гнев, отрицание, торг, изучение TypeScript).

**Подготовка среды**
Есть 2 варианта установки: локальная (в пределах проекта), и глобальная (на всем компьютере). Мы рассмотрим оба варианта.
1. Глобальная установка. Это самый простой вариант. Нам нужно в терминале (в любом месте), выполнить команду `npm install -g typescript`. Это установит TypeScript компилятор, и можно будет его вызывать в ЛЮБОМ месте. Чтобы проверить результат, наберите команду `tsc --version` - должен показать версию.
2. Локальная установка (так, как сделано в этом репозитарии). Такой вариант хорош, если Вы хотите добавить TypeScript как зависимость к проекту, не устанавливая его глобально. В этом случае, следует:
  - создать папку проекта
  - в ней, выполнить команду `npm init`. Это создаст нам файл `package.json`
  - выполнить команду `npm install typescript --save-dev`. Это установит TypeScript как зависимость проекта.
  - проверить результат командой `npx tsc --version`.

**Первые шаги**
Ура, TypeScript установлен, заготовка проекта создана. Пора писать код. Создадим папку `typescript`, в ней создадим файл `main.ts`,  и напишем в нем следующий фрагмент кода:
```
const myString = 'Hello World!';
console.log(myString);
```
Код подозрительно напоминает JS.. Попробуем его скомпилировать. Для этого, откроем терминал в этой папке, и запустим команду `npx tsc main.ts`. То есть, мы ЯВНО укажем, какой конкретно файл компилировать. Пока так.

Что получилось в результате? Мы видим, что у нас создался файл `main.js`. И вот этот файл (результат компиляции), мы уже можем подключить в наш `index.html`. Таким образом, мы скомпилировали файл TypeScript, и получили обычный JS-код, который может быть подключен к нашему проекту.

**Настраиваем компилятор**
Каждый раз компилировать эти файлы вручную скучно и долго. Можем немного ускорить процесс, и сразу прописать настройки компиляции. В этом нам поможет файл `tsconfig.json` - он уже создан, и в нем прописан ряд настроек. Пройдемся по каждой конкретнее.
```
{
  "compilerOptions": { // это объект с настройками компиляции
    "target": "ES2022",  // какую версию JS мы хотим получить на выходе
    "removeComments": false, // удалять ли комменты из исходного кода
    "sourceMap": true, // генерировать ли файл маппинга (рекомендуется - да, для отладки)
    "alwaysStrict": true, // строгий режим
    "outDir": "js" // директория, в которую сложим результирующий файл
  }
}
```
Теперь, попробуем скомпилировать наш файл, выполним команду `npx tsc`. В этом случае, компилятор подхватит настройки из `tsconfig`. Как видим - создана директория, и в ней создан файл.

**Типы в TypeScript**
Поговорим об основной фишке TypeScript, а именно - о типах. Здесь, мы можем (и должны!) явно указывать типы всего: переменных, аргументов функции, полей класса, и т.д. Но, чтобы указать кому-то его тип, хорошо бы понять, какими типами мы располагаем. Чаще всего, нам придется работать с примитивными типами, такими как `number`, `string`, `boolean`. Логика работы у них та же, что и в JS.

Попробуем это сделать на примере.
```
let myString: string = 'Hello TypeScript!';
myString = 'Wow, strict type system!'; // OK
myString = 5; // Wow, wow, man, stop it!
```
Мы видим, что нельзя просто взять и записать в переменную типа `string` переменную типа `number`. То есть, переопределение типов, столь любимое нами в JS, уходит в закат.

Еще момент. TypeScript достаточно умен, чтобы определять тип переменной "на лету". То есть, мы можем и не указывать тип переменной при ее объявлении.
```
let myString = 'Hello TypeScript!'; // TypeScript сам поймет, что это тип string
myString = 'Wow, strict type system!'; // OK
myString = 5; // Несудьба..
```
В принципе, написанный выше фрагмент кода вполне рабочий, но рекомендуется все же явно указывать типы - просто для улучшения читабельности, и единообразия.

Казалось бы, теперь никаких проблем с конкатенацией строк вместо суммы чисел, и все такое. Но нет: разработчики TypeScript оставили нам лазейку: тип `any`.

**Any-тип в TypeScript**
Это особый, уникальный тип, который существует только в TypeScript. Он как бы говорит "забудь все о типизации, и положи сюда все, что угодно". То есть по сути, он себя ведет как JS.
```
let result: any = 'Timon';
result = 'Pumba'; // OK
result = true; // не вопрос
result = 5; // все что угодно
result = {}; // и такое прокатит
```
Как видим, тип `any` лишает нас всех преимуществ сильной типизации, именно поэтому его НЕ рекомендуется использовать.

**Функции в TypeScript**
Как и переменные, все функции в TypeScript нужно типизировать. То есть, нужно прописывать аннотации типов для аргументов и для возвращаемого значения. Рассмотрим на примере:
```
function add(num1: number, num2: number) : number {
  return num1 + num2;
}
```
Мы видим, что указаны типы аргументов, и тип возвращаемого значения.

А что будет, если мы их не укажем? Пожалуй, ничего сверхстрашного - просто по умолчанию вылезет тип `any`.

Закрепим практикой.
 - Написать функцию, которая будет принимать 3 аргумента: имя (строка), возраст (число), и семейное положение (boolean). Функция должна вернуть строку следующего вида: `NAME is AGE years old and (not) married.`.
 - напишите функцию `checkAccess`. Она принимает имя (строку), и возраст (число), и возвращает boolean: истину если возраст больше 21, и ложь - если нет. При этом, вывести в консоль сообщение `NAME is AGE years old, checking access`.

А что делать, если функция ничего не возвращает? То есть, выполняет какую-то логику, и не имеет возвращаемого значения? Для этого, в TypeScript есть тип `void`. Это тип данных, который буквально означает "функция не возвращает ничего", и записывается следующим образом:
```
function logThis(text: string): void {
  console.log(text);
}
```

Закрепим практикой. Написать функцию `greet`, которая принимает в аргументах имя (строка), и просто выводит в консоль сообщение `Hello, NAME!`.

*Важный момент* относительно функций - это передача аргументов. Ранее, в JS, мы могли написать так:
```
function myFunction(arg1, arg2) {
  // ... something
}

myFunction(1);
myFunction(1,2);
myFunction(1,2,3);
```
И все будет работать. Если мы передаем аргументов меньше, чем описали в декларации функции - то недостающим аргументам будет присвоен undefined. А если передаем больше - то лишние аргументы будут проигнорированы.

TypeScript такого не допускает, попробуем в этом убедиться.
```
function myFunc(arg1: number, arg2: string) : void {
  console.log('something', arg1,  arg2)
}

myFunc(1); // Error
myFunc(1, '1'); // OK
myFunc(1, '1', 1); // Error
```

При этом, аргументы по умолчанию работают точно так же, как и в JS:
```
function myFunc(arg1: number, arg2: string = 'timon') : void {
  console.log('something', arg1,  arg2)
}

myFunc(1); // OK - we have the default value
myFunc(1, '1'); // OK
myFunc(1, '1', 1); // Error
```

**Необязательные аргументы**
В TypeScript можно отметить некоторые аргументы как необязательные (то есть, они могут не передаваться при вызове функции).
```
function myFunc(arg1: number, arg2?: string) : void {
  console.log('something', arg1,  arg2)
}

myFunc(1); // OK - the second argument is optional
myFunc(1, '1'); // OK
myFunc(1, '1', 1); // Error
```
Важный момент - необязательные аргументы передаются В КОНЦЕ спецификации функции.

**Массивы в TypeScript**
В TypeScript, массивы практически ничем не отличаются от массивов в JS - нужно только указывать им тип содержимого.
```
const arr: number[] = [1, 2, 3]
const arrOfStrings: string[] = ['1', '2', '3']

const arrOfArray: number[][] = [[1, 2, 3], [1, 2, 4]]
```
Автоопределение типов тоже работает для массивов.

Закрепим практикой.
 - Создать массив чисел. Пройти по массиву и вывести каждое число в консоль.
 - Написать функцию `getSum`, которая будет принимать массив чисел, и возвращать сумму его элементов.
 - написать функцию `convertNumsToStrings` - она должна принимать массив чисел, и возвращать массив строк.


## Полезные ссылки по занятию:
 - [Введение в RTL](https://www.youtube.com/watch?v=5IHc2qufxxM&list=PLM7wFzahDYnF9OoHLukLGX2XVJYLqLg4B ) - очень подробный и доходчивый вводный курс по TypeScript.
 - [Документация](https://www.typescriptlang.org/docs/) - англоязычная документация. На удивление, у них весьма толковый handbook - рекомендуется к ознакомлению (лучше параллельно с видеокурсом из п.1).